/**
* Systems Modeling API and Services
* REST/HTTP platform specific model (PSM) for the Systems Modeling API and Services
*
* The version of the OpenAPI document: 1.0
*
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openmbee.flexo.sysmlv2.apis

import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.auth.*
import io.ktor.server.resources.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.util.pipeline.*
import kotlinx.serialization.decodeFromString
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.*
import org.apache.jena.graph.Node
import org.apache.jena.graph.NodeFactory
import org.apache.jena.rdf.model.Property
import org.apache.jena.rdf.model.RDFNode
import org.apache.jena.vocabulary.DCTerms
import org.apache.jena.vocabulary.RDF
import org.openmbee.flexo.sysmlv2.*
import org.openmbee.flexo.sysmlv2.models.Commit
import org.openmbee.flexo.sysmlv2.models.CommitRequest
import org.openmbee.flexo.sysmlv2.models.DataVersion
import org.openmbee.flexo.sysmlv2.models.Identified
import java.time.OffsetDateTime
import java.util.*

class InvalidSysmlSerializationError(message: String): Error(message)

fun FlexoModelHandler.commitFromModel(
    commitIri: String,
    properties: Map<Property, Set<RDFNode>?>,
    projectUuid: UUID,
): Commit {
    // generate commit object
    return Commit(
        atId = UUID.fromString(commitIri.suffix),
        atType = Commit.AtType.Commit,
        created = OffsetDateTime.parse(properties[MMS.submitted]!!.literal()!!),
        description = properties[DCTerms.description]?.literal()?: "",
        owningProject = Identified(atId = projectUuid),
        previousCommit = properties[MMS.parent]?.map {
            Identified(atId = UUID.fromString(it.asResource().uri.suffix))
        }?: emptyList()
    )
}

fun Route.CommitApi() {
    get<Paths.getChangeByProjectCommitId> {
        val exampleContentString = """{
          "payload" : {
            "owner" : {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            },
            "textualRepresentation" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "ownedAnnotation" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "ownedElement" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "aliasIds" : [ "aliasIds", "aliasIds" ],
            "@type" : "Element",
            "ownedRelationship" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "documentation" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "isImpliedIncluded" : true,
            "declaredName" : "ActionDefinitionRequest_anyOf_declaredShortName",
            "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
          },
          "@type" : "DataVersion",
          "identity" : {
            "@type" : "DataIdentity",
            "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
          },
          "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
        }"""
        call.respond(Json.decodeFromString<DataVersion>(exampleContentString))
    }

    get<Paths.getChangesByProjectCommit> {
        val exampleContentString = """[ {
          "payload" : {
            "owner" : {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            },
            "textualRepresentation" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "ownedAnnotation" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "ownedElement" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "aliasIds" : [ "aliasIds", "aliasIds" ],
            "@type" : "Element",
            "ownedRelationship" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "documentation" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "isImpliedIncluded" : true,
            "declaredName" : "ActionDefinitionRequest_anyOf_declaredShortName",
            "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
          },
          "@type" : "DataVersion",
          "identity" : {
            "@type" : "DataIdentity",
            "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
          },
          "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
        }, {
          "payload" : {
            "owner" : {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            },
            "textualRepresentation" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "ownedAnnotation" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "ownedElement" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "aliasIds" : [ "aliasIds", "aliasIds" ],
            "@type" : "Element",
            "ownedRelationship" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "documentation" : [ {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            }, {
              "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
            } ],
            "isImpliedIncluded" : true,
            "declaredName" : "ActionDefinitionRequest_anyOf_declaredShortName",
            "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
          },
          "@type" : "DataVersion",
          "identity" : {
            "@type" : "DataIdentity",
            "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
          },
          "@id" : "046b6c7f-0b8a-43b9-b35d-6489e6daee91"
        } ]"""
        call.respond(Json.decodeFromString<List<DataVersion>>(exampleContentString))
    }

    get<Paths.getCommitByProjectAndId> { getCommits ->
        // submit GET request to retrieve project metadata
        val flexoResponse = flexoRequestPost {
            orgPath("/repos/${getCommits.projectId}/query")

            sparqlQuery {
                """
                    prefix mms: <${MMS.uri}>

                    select ?commit_p ?commit_o {
                        ?commit a mms:Commit ;
                            mms:id ${NodeFactory.createLiteral(getCommits.commitId.toString()).stringify()} ;
                            ?commit_p ?commit_o .
                    }
                """.trimIndent()
            }
        }

        // forward failures to client
        if(flexoResponse.isFailure()) {
            return@get forward(flexoResponse)
        }

//        flexoResponse.mapResults {
//            it["commit_p"]
//        }

        // parse the response model, convert it to JSON, and reply to client
        call.respond(flexoResponse.parseModel {
            // each commit node
            for(commit in indexInv(MMS.Commit.uri)[RDF.type]?: emptySet()) {
                // reference the commit's IRI
                val commitIri = commit.asResource().uri;

                // generate commit object
                commitFromModel(commitIri, indexOut(commitIri), getCommits.projectId)
            }
        })
    }

    get<Paths.getCommitsByProject> { getCommits ->
        // submit GET request to retrieve project metadata
        val flexoResponse = flexoRequestGet {
            orgPath("/repos/${getCommits.projectId}")
        }

        // forward failures to client
        if(flexoResponse.isFailure()) {
            return@get forward(flexoResponse)
        }

        // parse the response model, convert it to JSON, and reply to client
        call.respond(flexoResponse.parseModel {
            // each commit node
            for(commit in indexInv(MMS.Commit.uri)[RDF.type]?: emptySet()) {
                // reference the commit's IRI
                val commitIri = commit.asResource().uri;

                // generate commit object
                commitFromModel(commitIri, indexOut(commitIri), getCommits.projectId)
            }
        })
    }

    post<CommitRequest>("/projects/{projectId}/commits") { commit ->
        val projectId = "${call.parameters["projectId"]}"

        val inserts = mutableListOf<String>()
        val deletes = mutableListOf<String>()
        val wheres = mutableListOf<String>()

        // each change (DataVersionRequest)
        for((index, change) in commit.change.withIndex()) {
            val (payload, atType, identity) = change

            // handle combinations of potential identity id and payload id in DataVersionRequest
            // 1. identityId is present and payloadId is present: if they match, good, if not, bad
            // 2. identityId is present and payloadId is not present and payload is not null
            //     - use identityId
            // 3. both identityId and payloadId are not present, but payload is not null
            //     - generate a new uuid
            // 4. identityId is not present and payloadId is present
            //     - use payloadId
            val identityId = identity?.atId?.toString()
            var payloadId = payload?.getOrDefault("@id", null)?.jsonPrimitive?.content
            if (identityId != null && payloadId != null && identityId != payloadId) {
                //bad, log error?
                continue
            }
            if (identityId == null && payloadId == null && payload != null) {
                payloadId = UUID.randomUUID().toString() // generate an id
            }
            // subject node, target element
            var elementNode: Node = SYSMLV2.element(identityId ?: payloadId!!).asNode()
            // transform payload into property pairs
            mutableListOf<Pair<Property, Set<Node>>>().apply {
                // delete all outgoing properties, this happens for all elements whether being deleted or replaced or new
                // where clause have optional since we don't know if element exists or not
                deletes.add("""
                    ${elementNode.stringify()} ?p_$index ?o_$index .
                """.trimIndent())
                wheres.add("""
                    optional {
                        ${elementNode.stringify()} ?p_$index ?o_$index .
                    }
                """.trimIndent())
                if (payload == null) { //if payload is null, this is a delete, done
                    return@apply
                }

                // encode each key/value
                payload.forEach { (key, value) ->
                    // depending on the key
                    when(key) {
                        // reserved @type
                        "@type" -> add(RDF.type to setOf(SYSMLV2.element(payload["@type"]!!.jsonPrimitive.content).asNode()))

                        // everything else
                        else -> {
                            // depending on JSON type of value
                            when(value) {
                                // boolean, number, string
                                is JsonPrimitive -> {
                                    add(SYSMLV2.prop(key) to setOf(NodeFactory.createLiteral(value.content)))
                                }
                                // array
                                is JsonArray -> {
                                    // store entire array as serialized JSON
                                    add(SYSMLV2.annotation_json(key) to setOf(NodeFactory.createLiteral(Json.encodeToString(value))))

                                    // non-empty list and first element is an object
                                    if (value.isNotEmpty() && value[0] is JsonObject) {
                                        // create additional triples to link the elements
                                        add(SYSMLV2.prop(key) to value.jsonArray.map {
                                            SYSMLV2.element(it.jsonObject["@id"]!!.jsonPrimitive.content).asNode()
                                        }.toSet())
                                    }
                                }
                                // object - this means a reference
                                is JsonObject -> {
                                    add(SYSMLV2.prop(key) to setOf(SYSMLV2.element(value["@id"]!!.jsonPrimitive.content).asNode()))
                                }
                            }
                        }
                    }
                }

                // generate the RDF data for SPARQL INSERT clause
                inserts.add("""
                    ${elementNode.stringify()} ${joinToString(" ;\n\t") { pair ->
                        pair.first.stringify()+" "+pair.second.joinToString(", ") { it.stringify() }
                    }} .
                """.trimIndent())
            }
        }
/*    //no need to do any locks since we're always commiting to head of branch
        // first, lock the given commit
        val flexoResponseLock = flexoRequestPost {
            orgPath("/repos/$projectId/locks")

            turtle {
                """
                    <> mms:commit mor-commit:${commit.previousCommit} .
                """.trimIndent()
            }
        }

        // forward failures to client
        if(flexoResponseLock.isFailure()) {
            return@post forward(flexoResponseLock)
        }

        // extract lock ID from response model
        val lockId = flexoResponseLock.parseLdp {
            primary[MMS.id].literal()!!
        }
*/
        val body = """
                   delete {
                        ${deletes.joinToString("\n")}
                    }
                    insert {
                        ${inserts.joinToString("\n")}
                    }
                    where {
                        ${wheres.joinToString("\n")}
                        optional {
                            <urn:this> <urn:always> <urn:matches> .
                        }
                    }
                    
                """.trimIndent()
        // submit POST request to commit model
        val flexoResponseUpdate = flexoRequestPost {
            orgPath("/repos/$projectId/branches/master/update")

            // construct body payload
            sparqlUpdate {
                body
            }
        }

        // forward failures to client
        if(flexoResponseUpdate.isFailure()) {
            return@post forward(flexoResponseUpdate)
        }

        // parse the response model, convert it to JSON, and reply to client
        call.respond(flexoResponseUpdate.parseLdp {
            commitFromModel(self!!, primary, UUID.fromString(projectId))
        })
    }

}
